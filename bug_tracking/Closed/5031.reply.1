From: Chris Myers <atacs-bugs@vlsigroup.ece.utah.edu>
To: moschino21@gmail.com,thacker@vlsigroup.ece.utah.edu
Subject: Re: BUG: Delay expressions fails the lhpn parser (PR#5031)
Date: Wed Jun 30 16:34:27 2010

Hi Zhen,

If there is a bounded delay, it now must be put into a uniform statement. 
Namely, it should be:

uniform(delayL+1,delayU+2)

The only time you can use the [l,u] is when l and u are numbers.  If they are
expressions, it must be enclosed in uniform.  Therefore, this is a bug in either
the instruction file or s compiler.

Robert: please look into this.

Chris

 --000e0cd32ed8db4f1304892ffecf
> Content-Type: text/plain; charset=ISO-8859-1
> 
> I compiled the following .s file, which contains expressions for delay
> assignments, to .lpn and it looks that the generated LPN file is correct.
> When I bring it up in the transition editor, the delay assignment for t0
> becomes uniform(delayL,delayU), but t1 is (delayL+1),(delayU+2), which
> generates an error for t1.
> 
> ;@ include <example.inst>
> ;@ init_val    tcnt0 0
> ;@ init_val    tmax0 65536
> ;@ init_val    delayL 1
> ;@ init_val    delayU 1
> ;@ mark
> t_count    set_val tcnt0<=tmax0 tcnt0 tcnt0+1 delayL delayU
>         link t_count
> t_count    set_val tcnt0>tmax0 tcnt0 0 (delayL+1) (delayU+2)
>         link t_count
> 
> Generated LPN file:
> .dummy t0 t1
> #@.variables delayL delayU tcnt0 tmax0
> #|.places t_count
> .graph
> t_count t0
> t0 t_count
> t_count t1
> t1 t_count
> .marking { t_count }
> #@.init_vals {<delayL=1><delayU=1><tcnt0=0><tmax0=65536>}
> #@.enablings {<t0=[tcnt0<=tmax0]><t1=[tcnt0>tmax0]>}
> #@.assignments {<t0=[tcnt0:=tcnt0+1]><t1=[tcnt0:=0]>}
> #@.delay_assignments {<t0=[delayL,delayU]><t1=[(delayL+1),(delayU+2)]>}
> .end
> -- 
> Zhen Zhang
> 
> --000e0cd32ed8db4f1304892ffecf
> Content-Type: text/html; charset=ISO-8859-1
> Content-Transfer-Encoding: quoted-printable
> 
> I compiled the following .s file, which contains expressions for delay assi=
> gnments, to .lpn and it looks that the generated LPN file is correct. When =
> I bring it up in the transition editor, the delay assignment for t0 becomes=
>  uniform(delayL,delayU), but t1 is (delayL+1),(delayU+2), which generates a=
> n error for t1. <br>
> 
> <br>;@ include <example.inst><br>;@ init_val=A0=A0=A0 tcnt0 0<br>;@ i=
> nit_val=A0=A0=A0 tmax0 65536<br>;@ init_val=A0=A0=A0 delayL 1<br>;@ init_va=
> l=A0=A0=A0 delayU 1<br>;@ mark<br>t_count=A0=A0=A0 set_val tcnt0<=3Dtmax=
> 0 tcnt0 tcnt0+1 <span style=3D"background-color: rgb(255, 204, 0);">delayL =
> delayU</span><br>
> 
> =A0=A0=A0 =A0=A0=A0 link t_count<br>t_count=A0=A0=A0 set_val tcnt0>tmax0=
>  tcnt0 0 <span style=3D"background-color: rgb(255, 204, 0);">(delayL+1) (de=
> layU+2)</span><br>=A0=A0=A0 =A0=A0=A0 link t_count<br><br>Generated LPN fil=
> e: <br>.dummy t0 t1<br>#@.variables delayL delayU tcnt0 tmax0<br>
> 
> #|.places t_count<br>.graph<br>t_count t0<br>t0 t_count<br>t_count t1<br>t1=
>  t_count<br>.marking { t_count }<br>#@.init_vals {<delayL=3D1><del=
> ayU=3D1><tcnt0=3D0><tmax0=3D65536>}<br>#@.enablings {<t0=
> =3D[tcnt0<=3Dtmax0]><t1=3D[tcnt0>tmax0]>}<br>
> 
> #@.assignments {<t0=3D[tcnt0:=3Dtcnt0+1]><t1=3D[tcnt0:=3D0]>}<b=
> r><span style=3D"background-color: rgb(255, 204, 0);">#@.delay_assignments =
> {<t0=3D[delayL,delayU]><t1=3D[(delayL+1),(delayU+2)]>}</span><b=
> r>.end<br>
> 
> -- <br>Zhen Zhang<br>
> 
> --000e0cd32ed8db4f1304892ffecf--
> 
> 