From killpack@eng.utah.edu  Thu May  4 14:48:35 2000
Return-Path: <killpack@eng.utah.edu>
Received: from localhost (killpack@localhost)
	by chou.elen.utah.edu (8.9.3/8.9.3) with ESMTP id OAA06284
	for <atacs-bugs@shang.elen.utah.edu>; Thu, 4 May 2000 14:48:35 -0600
X-Authentication-Warning: chou.elen.utah.edu: killpack owned process doing -bs
Date: Thu, 4 May 2000 14:48:35 -0600 (MDT)
From: Kip Killpack <killpack@eng.utah.edu>
X-Sender: killpack@chou.elen.utah.edu
To: atacs-bugs@shang.elen.utah.edu
Subject: storevhd added inverters that break it.
Message-ID: <Pine.LNX.4.10.10005041444140.6264-100000@chou.elen.utah.edu>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII

Store vhd adds inverters for the input signals at the bottom - it also is
adding inverters for the output signals - but the output signals get
inverted in the gC gates - so outputsignal_bar is getting driven from the
gC and the inverter at the bottom.

file: and2_a.hse
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
/*
--------------------------------------------------------------------------
 ** pre-charged half-buffer AND gate
 ** command line: 
 ** atacs -mV -mE -mz -mU -mP -mT -ms -mc -mD -eR -lh -M20 -ya -sv
and2_a.hse
 **
 ** and2_a.prs
 **
 */
module and2_a;

delay celtgate  = <65, 135>;
delay standgate = <33, 67>;
delay envdelay  = <65, inf>;    /* 1 celt gate */

output aibar = { true, standgate };
output bibar = { true, standgate };
output ci    = { true, standgate };
output abi   = { true, celtgate };
output en    = { true, celtgate };

input a0 = {false, envdelay};
input a1 = {false, envdelay};

input b0 = {false, envdelay};
input b1 = {false, envdelay};

input  ce = {false, envdelay};
output c0 = {false, celtgate};
output c1 = {false, celtgate};


process main;
*[ 
   [ce];
   [ b0 & a0 -> c0+ |
     a0 & b1 -> c0+ |
     a1 & b0 -> c0+ |
     a1 & b1 -> c1+ ]; 
 
   [~en];   /* en- */   
   [~ce];
   [ c0 -> c0- | c1 -> c1- ];
   [ ~a0 & ~a1 & ~b0 & ~b1 ];
   [en]    /* en+ */
]
endprocess

/*
---------------------------------------------------------------------------
 ** Gate descriptions for en
 **
---------------------------------------------------------------------------
 */
gate aibar;
  ( a0 | a1 ) -> aibar-
  ( ~a0 & ~a1 ) -> aibar+
endgate

gate bibar;
  ( b0 | b1 ) -> bibar-
  ( ~b0 & ~b1 ) -> bibar+
endgate

gate ci;
  ( c0 | c1 ) -> ci-
  ( ~c0 & ~c1 ) -> ci+
endgate

gate abi;
  ( ~aibar & ~bibar ) -> abi-
  ( aibar & bibar ) -> abi+
endgate

gate en;
  ( ~abi & ~ci ) -> en-
  ( abi & ci ) -> en+
endgate

/*
---------------------------------------------------------------------------
 ** Environment processes
 **
---------------------------------------------------------------------------
 */

process a;
*[ 
   [ true -> a0+ | true -> a1+ ]; 
   [~en]; 
   [ a0 -> a0- | a1 -> a1- ];
   [en]
 ]
endprocess

process b;
*[ 
   [ true -> b0+ | true -> b1+ ]; 
   [~en]; 
   [ b0 -> b0- | b1 -> b1- ];
   [en]
 ]
endprocess

process c;
*[ 
   ce+; 
   [ c0 | c1 ]; 
   ce-; 
   [ ~c0 & ~c1 ] 
 ]
endprocess

endmodule

storevhd: and2_aS.vhd
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
library ieee;
use ieee.std_logic_1164.all;
use work.nondeterminism.all;

entity and2_a is
  port(   a0 : in std_logic;
          a1 : in std_logic;
         abi : inout std_logic;
       aibar : inout std_logic;
          b0 : in std_logic;
          b1 : in std_logic;
       bibar : inout std_logic;
          c0 : inout std_logic;
          c1 : inout std_logic;
          ce : in std_logic;
          ci : inout std_logic;
          en : inout std_logic
       );
end and2_a;


architecture structure of and2_a is

  -- internal signal declarations
  -- input complements
  signal a0_bar: std_logic;
  signal a1_bar: std_logic;
  signal b0_bar: std_logic;
  signal b1_bar: std_logic;
  signal c0_bar: std_logic;
  signal c1_bar: std_logic;
  signal ce_bar: std_logic;

  -- output complements
  signal abi_bar: std_logic;
  signal aibar_bar: std_logic;
  signal bibar_bar: std_logic;
  signal ci_bar: std_logic;
  signal en_bar: std_logic;


  component a2h
  port(a1 : in std_logic;
       b1 : in std_logic;
       o : inout std_logic);
  end component;

  component n2p2h
  port(a1n : in std_logic;
       b1n : in std_logic;
       a1p : in std_logic;
       b1p : in std_logic;
       o : inout std_logic;
       obar : inout std_logic);
  end component;

  component n4n4n4p2
  port(a1n : in std_logic;
       b1n : in std_logic;
       c1n : in std_logic;
       d1n : in std_logic;
       a2n : in std_logic;
       b2n : in std_logic;
       c2n : in std_logic;
       d2n : in std_logic;
       a3n : in std_logic;
       b3n : in std_logic;
       c3n : in std_logic;
       d3n : in std_logic;
       a1p : in std_logic;
       b1p : in std_logic;
       o : inout std_logic;
       obar : inout std_logic);
  end component;

  component n4p2
  port(a1n : in std_logic;
       b1n : in std_logic;
       c1n : in std_logic;
       d1n : in std_logic;
       a1p : in std_logic;
       b1p : in std_logic;
       o : inout std_logic;
       obar : inout std_logic);
  end component;

begin
  i_0 : n4n4n4p2
    port map(a1n=>a1, b1n=>b0, c1n=>ce, d1n=>en, 
             a2n=>a0, b2n=>b1, c2n=>ce, d2n=>en, 
             a3n=>a0, b3n=>b0, c3n=>ce, d3n=>en, 
             a1p=>ce, b1p=>en, 
             o=>c0, obar=>c0_bar);

  i_1 : n4p2
    port map(a1n=>a1, b1n=>b1, c1n=>ce, d1n=>en, 
             a1p=>ce, b1p=>en, 
             o=>c1, obar=>c1_bar);

  i_2 : a2h
    port map(a1=>c0_bar, b1=>c1_bar, 
             o=>ci);

  i_3 : a2h
    port map(a1=>b0_bar, b1=>b1_bar, 
             o=>bibar);

  i_4 : a2h
    port map(a1=>a0_bar, b1=>a1_bar, 
             o=>aibar);

  i_5 : n2p2h
    port map(a1n=>bibar, b1n=>aibar, 
             a1p=>bibar, b1p=>aibar, 
             o=>abi, obar=>abi_bar);

  i_6 : n2p2h
    port map(a1n=>ci, b1n=>abi, 
             a1p=>ci, b1p=>abi, 
             o=>en, obar=>en_bar);

  -- complements of inputs
  a0_bar <= not a0 after delay(0,1);
  a1_bar <= not a1 after delay(0,1);
  b0_bar <= not b0 after delay(0,1);
  b1_bar <= not b1 after delay(0,1);
  c0_bar <= not c0 after delay(0,1);
  c1_bar <= not c1 after delay(0,1);
  ce_bar <= not ce after delay(0,1);

end structure;




