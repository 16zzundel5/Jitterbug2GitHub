From atacs-bugs  Mon Jun  5 09:31:48 2000
Return-Path: <atacs-bugs>
Received: (from atacs-bugs@localhost)
	by chou.elen.utah.edu (8.9.3/8.9.3) id JAA24646
	for atacs-bugs@shang.elen.utah.edu; Mon, 5 Jun 2000 09:31:48 -0600
Received: from jiaqi.elen.utah.edu (IDENT:myers@jiaqi.elen.utah.edu [155.99.23.199])
	by chou.elen.utah.edu (8.9.3/8.9.3) with ESMTP id JAA24643
	for <atacs-bugs@vlsigroup.elen.utah.edu>; Mon, 5 Jun 2000 09:31:47 -0600
Received: (from myers@localhost)
	by jiaqi.elen.utah.edu (8.9.3/8.9.3) id JAA01008
	for atacs-bugs@vlsigroup; Mon, 5 Jun 2000 09:35:23 -0600
From: "Chris J. Myers" <myers@vlsigroup.elen.utah.edu>
Message-Id: <200006051535.JAA01008@jiaqi.elen.utah.edu>
Subject: handshake.vhd (fwd)
To: atacs-bugs@vlsigroup.elen.utah.edu
Date: Mon, 5 Jun 2000 09:35:23 -0600 (MDT)
X-Mailer: ELM [version 2.5 PL0pre8]
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

From killpack@eng.utah.edu  Thu May 18 15:34:47 2000
Return-Path: <killpack@eng.utah.edu>
Received: from wrath.cs.utah.edu (wrath.cs.utah.edu [155.99.198.100])
	by chou.elen.utah.edu (8.9.3/8.9.3) with ESMTP id PAA24184
	for <myers@ching.elen.utah.edu>; Thu, 18 May 2000 15:34:47 -0600
Received: from ee.elen.utah.edu (postfix@ee.elen.utah.edu [128.110.18.3])
	by wrath.cs.utah.edu (8.8.8/8.8.8) with ESMTP id PAA12740
	for <cmyers@cs.utah.edu>; Thu, 18 May 2000 15:34:46 -0600 (MDT)
Received: by ee.elen.utah.edu (Postfix)
	id 9638F5440; Thu, 18 May 2000 15:34:46 -0600 (MDT)
Delivered-To: myers@elen.utah.edu
Received: from chou.elen.utah.edu (chou.elen.utah.edu [155.99.23.202])
	by ee.elen.utah.edu (Postfix) with ESMTP id 7A5F4543F
	for <myers@elen.utah.edu>; Thu, 18 May 2000 15:34:46 -0600 (MDT)
Received: from localhost (killpack@localhost)
	by chou.elen.utah.edu (8.9.3/8.9.3) with ESMTP id PAA24180
	for <myers@elen.utah.edu>; Thu, 18 May 2000 15:34:46 -0600
X-Authentication-Warning: chou.elen.utah.edu: killpack owned process doing -bs
Date: Thu, 18 May 2000 15:34:46 -0600 (MDT)
From: Kip Killpack <killpack@eng.utah.edu>
X-Sender: killpack@chou.elen.utah.edu
To: "Chris J. Myers" <myers@elen.utah.edu>
Subject: handshake.vhd
Message-ID: <Pine.LNX.4.10.10005181533250.24169-100000@chou.elen.utah.edu>
MIME-Version: 1.0
Content-Type: TEXT/PLAIN; charset=US-ASCII

--\begin{verbatim}
----------------------------------------------------------
-- Name: handshake.vhd
----------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use work.nondeterminism.all;

package handshake is



  procedure assign(signal sig1 : inout std_logic;     -- 0 delay
                   constant val1 : std_logic);

  procedure assign(signal sig1 : inout std_logic;     -- 0 delay
                   constant val1 : std_logic;
		   signal sig2 : inout std_logic;
                   constant val2 : std_logic);

  procedure assign(signal sig1 : inout std_logic;     -- const delay
(del1)
                   constant val1 : std_logic;
                   constant del1 : time);

  procedure assign(signal sig1 : inout std_logic; -- random delay
(l,u)*scale
                   constant val1 : std_logic;
                   constant l1 : integer;
                   constant u1 : integer;
		   constant scale1 : time);

  procedure assign(signal sig1 : inout std_logic; -- random delay
(l,u)*scale
                   constant val1 : std_logic;
                   constant l1 : integer;
                   constant u1 : integer;
		   constant scale1 : time;
                   signal sig2 : inout std_logic;
                   constant val2 : std_logic;
                   constant l2 : integer;
                   constant u2 : integer;
		   constant scale2 : time);

  procedure guard(signal sig1 : in std_logic;
                  constant val1 : std_logic);

  procedure guard_or(signal sig1 : in std_logic;
                     constant val1 : std_logic;
                     signal sig2 : in std_logic;
                     constant val2 : std_logic );

  procedure guard_and(signal sig1 : in std_logic;
                      constant val1 : std_logic;
                      signal sig2 : in std_logic;
                      constant val2 : std_logic );
end handshake;



package body handshake is
  function sig_val(sig : in std_logic) return string is
    variable str:string(1 to 1);
  begin
    case sig is
    when 'X' => str(1) := 'X';
    when 'U' => str(1) := 'U';
    when 'Z' => str(1) := 'Z';
    when '0' => str(1) := '0';
    when '1' => str(1) := '1';
    when '-' => str(1) := '-';
    when 'W' => str(1) := 'W';
    when 'L' => str(1) := 'L';
    when 'H' => str(1) := 'H';
    when others => str(1) := '0';
    end case;
    return(str);
  end sig_val;
  
  procedure assign(signal sig1 : inout std_logic;
                   constant val1 : std_logic) is
  begin
    assert (sig1 /= val1) 
      report "Signal 1: attempted vacuous assign from " & sig_val(sig1) &
             " to " & sig_val(val1) & "."
      severity failure;
    sig1 <= val1;
    wait until sig1 = val1;
  end assign;

  procedure assign(signal sig1 : inout std_logic;     -- 0 delay
                   constant val1 : std_logic;
		   signal sig2 : inout std_logic;
                   constant val2 : std_logic) is
  begin
    assert (sig1 /= val1) 
      report "Signal 1: attempted vacuous assign from " & sig_val(sig1) &
      " to " & sig_val(val1) & "."
      severity failure;
    assert (sig2 /= val2) 
      report "Signal 2: attempted vacuous assign from " & sig_val(sig2) &
      " to " & sig_val(val2) & "."
      severity failure;
    sig1 <= val1;
    sig2 <= val2; 
    wait until sig1 = val1 and sig2 = val2;
  end assign;


  procedure assign(signal sig1 : inout std_logic;
                   constant val1 : std_logic;
                   constant del1 : time) is
  begin
    assert (sig1 /= val1) 
      report "Signal 1: attempted vacuous assign from " & sig_val(sig1) &
      " to " & sig_val(val1) & "."
      severity failure;
    sig1 <= val1 after del1;
    wait until sig1 = val1;
  end assign;
  
  procedure assign(signal sig1 : inout std_logic;
                   constant val1 : std_logic;
                   constant l1 : integer;
                   constant u1 : integer;
		   constant scale1 : time) is
  begin
    assert (sig1 /= val1) 
      report "Signal 1: attempted vacuous assign from " & sig_val(sig1) &
      " to " & sig_val(val1) & "."
      severity failure;
    sig1 <= val1 after delay(l1, u1, scale1);
    wait until sig1 = val1;
  end assign;

  procedure assign(signal sig1 : inout std_logic;
                   constant val1 : std_logic;
                   constant l1 : integer;
                   constant u1 : integer;
		   constant scale1 : time;
                   signal sig2 : inout std_logic;
                   constant val2 : std_logic;
                   constant l2 : integer;
                   constant u2 : integer;
		   constant scale2 : time) is
  begin
    assert (sig1 /= val1) 
      report "Signal 1: attempted vacuous assign from " & sig_val(sig1) &
      " to " & sig_val(val1) & "."
      severity failure;
    assert (sig2 /= val2) 
      report "Signal 2: attempted vacuous assign from " & sig_val(sig2) &
      " to " & sig_val(val2) & "."
      severity failure;
    sig1 <= val1 after delay(l1, u1, scale1);
    sig2 <= val2 after delay(l2, u2, scale2);
    wait until sig1 = val1 and sig2 = val2;
  end assign;

  procedure guard(signal sig1 : in std_logic;
                  constant val1 : std_logic) is
  begin
    if (sig1 /= val1) then
      wait until sig1 = val1;
    end if;
  end guard;

  procedure guard_or(signal sig1 : in std_logic;
                     constant val1 : std_logic;
                     signal sig2 : in std_logic;
                     constant val2 : std_logic ) is
  begin
    if ( (sig1 /= val1) and (sig2 /= val2) ) then
      wait until ( (sig1 = val1) or (sig2 = val2) );
    end if;
  end guard_or;

  procedure guard_and(signal sig1 : in std_logic;
                      constant val1 : std_logic;
                      signal sig2 : in std_logic;
                      constant val2 : std_logic ) is
  begin
--    if ( (sig1 /= val1) or (sig2 /= val2) ) then
--      wait until ( (sig1 = val1) and (sig2 = val2) );
--    end if;
    if ( (sig1 /= val1) or (sig2 /= val2) ) then
      wait until ( (sig1 = val1) and (sig2 = val2) );
    end if;
  end guard_and;

end handshake;



